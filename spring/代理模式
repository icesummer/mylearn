1、接口

2、目标类

3、代理类


为什么目标类和代理类要实现同样的接口：

	针对一般代理模式，这样做的目的在客户端感觉不出来是代理类在起作用


一般的代理模式的缺点：

	在换一个业务逻辑的时候，只有权限类能够重用，而目标类和接口是没有办法重用的。
	
动态代理：

	1、JDK的动态代理
	
	2、CGLIB的动态代理
	
	
	共同的特点：代理类不是由程序员来写的，而是动态生成的
	
	
jdk的动态代理：

1、接口

2、目标类

3、拦截器

	实现了InvocationHandler接口的类就是拦截器   jdk拦截器
	
	动态产生的代理类和目标类实现了共同的接口
	
	在invoke方法中，在调用目标类的目标方法的上下文可以添加一些代码，这些代码可以是事务的开启和提交，也可以是权限判断，还可以是日志文件。可以认为这些代码是
	 
	阻拦目标类的目标方法的执行
	
4、代理类

	是由Proxy.newProxyInstance来动态生成
	
	代理类的方法体内容就是拦截器中invoke中的方法体的内容
	
	invoke方法是：权限判断（事务处理）+目标类的目标方法的结合体
	
	
	Privieage(Transaction)    +   目标类的目标方法    ----》代理类
	
	
	
cglib代理:是由cglib包产生


组成：

1、目标类

2、拦截器

3、代理类



1、把cglib的包导入进去



说明：在cglib中产生的代理类和目标类是继承关系


jdkproxy和cglib代理的区别和联系：


如果用jdkproxy，写一个目标类就需要写一个接口


而cglib代理不需要这么麻烦


jdkproxy在客户端是面向接口编程   所以耦合性比较低

cglib在客户端是目标对象编程   所以耦合性比较高




AOP的概念：

1、切面：

	Transaction    Privilege
	
2、连接点：

	在客户端调用的目标方法
	
3、切入点：

	deletePerson   savePerson  就是所说的切入点
	
	
连接点是切入点的子集


切入点是目标类的目标方法的子集


只有纳入到切入点的方法才要把切面加入进来



4、通知：

	通知是切面中的方法
	
	
	
通知是切面这个类中的一个方法



5、目标对象

	就是目标类的目标对象
	
6、织入

	就是把切面中的通知和目标类的目标方法结合在一起的过程，形成拦截器中invoke方法的过程叫织入
	
	
7、各种各样的通知

	是针对目标类的目标方法的位置而言的



	


