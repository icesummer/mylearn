二进制补码：
1、计算机中数值一律用二进制存储
2、二进制的最高位是符号位，0表示正数，1表示负数
3、正数的值是其本身，负数的值是最高位(符号位)不变，其它位逐位取反，再加1
如：1101的值是：1)逐位取反:0010，2)加1:0011，3)0011的十进制是3，所以1101的十进制是-3；

1、二进制两数相加，若最高位(符号位)有进位，则进位被舍弃；
如：四位二进制补码中：5-3=2对应的二进制减法为：0101+1101=0010	

为什么使用补码：
	1、可以将符号位和其它位统一处理；
	2、最高为不再表示数值，而是作为符号位，正好将数值折半，即一半是0正数，一半是负数。
		1)如：4位二进制数共有16个数(2的4次方)，用补码表示，则一半是0~7，-1~-8
		2)如：8位二进制数共有256个数(2的8次方)，用补码表示，则一半是0~127，-1~-128
	3、减法也可以按加法来处理；
		如：7-3，二进制表示为0111+1101=0100
		
补码运算的特征：
	1、计算机中正数和负数的关系是取反加1  如：0011(3)的负数：1)取反1100，2)加1：1101=-3
	2、补码运算是封闭的：运算结果保留在补码范围内，超范围就溢出；
	3、4位二进制数补码最多能表示16个数(2的4次方)，数的范围是-8~7
	   8位二进制数补码最多能表示256个数(2的8次方)，数的范围是-128~127
	   16位二进制数补码最多能表示65536个数(2的16次方)，数的范围是-32768~32767
	   32位二进制补码最多能表示2的32次方个数(2的32次方)，数的范围是-2的32次方~2的32次方减1

补码运算的原理：
	正数+负数=模
	模：某种数据类型的总和，例如：
		4位二进制的模就是2的4次方16；
		8位二进制的模就是2的8次方256；
		16位二进制的模就是2的16次方65536；
		32位二进制的模就是2的32次方；
	在4位二进制运算中：7+(-7)=16 ==== 0111+1001=10000(16) 16就是模 ，
	因此推出：负数=模-正数，10000-00111=01001(后4位)
	而负数正好就是正数的取反+1得来  这就是逐位取反加1的原因
	


    补码表示中，最高位为符号位，正数的符号位为0，负数为1
    x<<n 表示x左移n位=x*2的n次方 后位补0
    x>>n 表示x右移n位=x/2的n次方 高位是0(整数)补0(负数补1) -- 最高位是0则为整数，为1则为负数

    x>>>n 表示无符号位移x/2的n次方 ，高位无论是0还是1(即无论正负)都补0

    同位与运算&，二进制同位都是1 取1，其它取0
    同位或运算|，二进制同位只要有一个是1，就取1，其它0
             0 0 0 0 1 1 0 0 = 12
             0 0 0 0 0 1 0 1 = 5
    12&5:    0 0 0 0 0 1 0 0 = 4
    12|5:    0 0 0 0 1 1 0 1 = 13

    异或运算^，二进制同位相同都是0，不同取1
    取反运算~，整数二进制取反码再补码加一就是负数
                如对 a 按位取反，则得到的结果为 -(a+1) 
             0 0 0 0 1 1 0 0 = 12
             0 0 0 0 0 1 0 1 = 5
    12^5:    0 0 0 0 1 0 0 1 = 9
    +12 :    0 0 0 0 1 1 0 0 = 12
        :    1 1 1 1 0 0 1 1 = 反码
    ~12 :    1 1 1 1 0 1 0 0 = +1=-13 反码补码



    8        0 0 0 0 1 0 0 0
    -8       1 1 1 1 1 0 0 0
    8>>2     0 0 0 0 0 0 1 0 8右移2位=8/2平方
    -8>>2    1 1 1 1 1 1 1 0 -8右移2位=8/2平方补1
    -8>>>2   0 0 1 1 1 1 1 0 -8右移2位=8/2平方补0
    8<<2     1 1 1 1 1 1 1 0 8左移2位=8*2平方


浮点类型用于表示小数的数据类型
浮点数原理：二进制科学计数法
十进制浮点科学计数法是：219345=2.19345*(10^5) (=尾数*底数乘以10的5次幂)
二进制浮点科学计数法是：10111=1.0111*(2^100) (=尾数*底数乘以2的100次幂)
（10^5次幂运算：10乘以5次）
说明如：2.19345*(10^5)
		尾数：2.19345
		底数：10
		指数：5

Java中的float类型
	共32位，1位是符号位，指数8位，尾数23位
	所以float精度是23位，(超过被截取)
	float小数以尾数长度表示精度的(如3.1415的精度是4位)
	float的存储范围是10的38次方，大于int的范围，但精度(23位)比int(31为位)小；(int有一位符号位)
	
Java中的double类型
	共64位，1位是符号位，指数11位，尾数52位
	double的存储范围大于long的范围，但精度(52位)比long(63为位)小；(long有一位符号位)


Java中的浮点类型运算
	浮点运算就是实数运算，由于计算机只能存储整数，所以实数都是约数，这样浮点运算很慢而且会有误差；
	如double a=2.6  double e = a-2;  e=0.6000000000000001
	所以，1、在数值运算中尽量使用整形运算；
		  2、在比较两个浮点值大小时，一定不能用等于比较，要用范围值比较
	
Java中的字符类型char
	Java底层使用一个16位的证书来处理字符类型，该数值是一个字符的unicode编码值
	(Unicode是全球范围的编码方法，英文部分与ASCII码兼容，ASCII表示0~128(美国国家标准编码))
	
	***什么是编码：计算机硬件系统只能用0和1表示，人为规定了某个数还可以表示一个字符，如65代表字符A
	
	小字节向大字节转换会自动完成，规则：符号位自动扩展，负数补1，正数补0；
	Java字节从小到大：byte<short<int<long<float<double
			int自动换为float时由于int经度大于float会出现精度误差问题
	
	
	
	
	