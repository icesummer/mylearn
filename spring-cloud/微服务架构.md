# 微服务

- 微服务架构是一种架构思想，目的是为了解耦(将主业务逻辑与交叉业务分离，提高灵活性)，实际开发中采用分布式系统开发
- 实现高性能，高并发，高可用
- 三个标准：提高敏捷性，用户体验，降低成本

>微服务架构解决的问题：
>
>1. API Gateway（网关解决客户端访问问题）
>2. 服务间的通信
>3. 服务发现(服务治理)
>4. 服务容错
>5. 服务部署
>6. 数据调用y



云计算+微服务+服务网格+云架构（serverless）+区块链+大数据+人工智能

CAP理论

BASE理论



## 分布式事务协议

> 背景
> 在分布式系统里，每个节点都可以知晓自己操作成功还是失败，却无法知道其它节点，当一个事务跨多个节点时，为了保持事务的原子性和一致性，而引入一个协调者来统一掌管所有参与者的操作结果，并决定将操作结果进行最终的提交或者回滚

### 二阶段提交: (Two-phase commit,即 2pc )

> 2PC 是常用的分布式事务解决方案，即将事务提交过程分为两个阶段进行处理：

* 两个阶段：1 准备阶段，2 提交阶段
* 角色：协调者(事务发起者)，参与者(事务执行者)

> 第一阶段(voting phase -投票阶段) 

* 1 协调者向参与者发送事务内容，询问是否可以提交事务(即能否顺利执行)，并等待答复

* 2 各参与者执行事务，将undo和redo信息记入事务日志(但不提交事务)

* 3 如参与者执行成功，给协调者反馈同意，否则反馈中止；

  ```mermaid
  graph LR
  	pA[事务发起者] -.发起请求--> 1[协调者MQ]
  	1[协调者MQ]  -.询问同意?.->A[参与者A] -.订单服务.创建订单.-A[参与者A] -.uncommit.unlog.->C[DB-订单]
  	1[协调者MQ]  -.询问同意?.->B[参与者B] -.库存服务.减库存 .-B[参与者B] -.uncommit.unlog.->D[DB-库存]
  	
  ```
  
  法
  
  

> 第二阶段(commit phase -提交执行阶段 )

* 当协调者节点从所有参与者节点获得的对应消息都是**<u>同意</u>**时：

  1. 协调者节点向所有参与者节点发送**正式提交(commit)**请求；
  2. 参与者正式完成commit操作，并释放整个事务期间内占用的资源；
  3. 参与者向协调者发送ack完成消息；
  4. 协调者收到所有参与者返回的ack完成消息后，完成事务；

-- 最终提交

```mermaid
    graph LR
  	pA[参与者A] -.同意--> 1[协调者MQ]
  	pB[参与者B] -.同意--> 1[协调者MQ]
  	1[协调者MQ]  -.都同意-->A[参与者A] -.commited.->2[协调者MQ] 
  	1[协调者MQ]  -.都同意-->B[参与者B] -.commited.->2[协调者MQ] -.->C[完成事务]
```
-- 回滚

```mermaid
    graph LR
  	pA[参与者A] -.不同意或无响应--> 1[协调者MQ]
  	pB[参与者B] -.同 -意--> 1[协调者MQ]
  	1[协调者MQ]  -.不同意请回滚.->A[参与者A] -.回滚ACK.->2[协调者MQ] 
  	1[协调者MQ]  -.不同意请回滚.->B[参与者B] -.回滚ACK.->2[协调者MQ] -.->C[取消事务]	
```

- 优点：最大可能保证了数据的强一致性，
- 缺点：牺牲可用性，对性能影响较大，不适合高并发场景



### 三阶段提交: (Three-phase commit,即 3pc )

>  是对二阶段协议的改进版本，包含两个方面

 1. 在协调者和参与者中都引入超时机制

 2. 在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各个参与节点状态一致

     也就是把2pc的准备阶段再次一分为二，形成了3PC：

    - CanCommit	询问参与者是否可以执行
    - PreCommit	协调者接受到可以，向参与者发送预执行请求，但不commit  (undo提交，记录到事务日志)
    - DoCommit	根据参与者返回的ack结果，协调者向参与者发出或参与者自动事务提交commit 或取消
      - 问题：在第3docommit阶段，如果协调者发出abort中断事务指令，但其中一个参与者未收到依然发送commit会出现脏数据；



## 分布式事务解决方案

- TCC
- 全局消息
- 基于可靠消息服务的分布式事务
- 最大努力通知



### TCC模式（事务补偿）

Try Confirm OR Cancel

TCC方案是一种应用层面侵入业务的两阶段提交，是目前最火的一种柔性事务方案，其核心思想是**针对每个操作都要注册一个与其对应的确认和补偿(撤销)操作**

1. 第一阶段

   TRy(尝试)：主要对业务系统做检测及资源预留（加锁资源）

   2. 第二阶段

      根据第一阶段的结果，决定是执行confirm(真正提交业务)还是cancel   释放资源

      Confirm（确认）：执行真正的业务提交，执行业务释放锁

      Cancel   （取消）：是对预留资源的取消，出问题释放锁

#### ByteTCC

byteTcc是TCC方案的一个开源实现

https://github.com/liuyangming/ByteTCC

* ByteTCC特性
\* 1、支持Spring容器的声明式事务管理；
\* 2、支持普通事务、TCC事务、业务补偿型事务等事务机制；
\* 3、支持多数据源、跨应用、跨服务器等分布式事务场景；
\* 4、支持长事务；
\* 5、支持dubbo服务框架；
\* 6、支持spring-cloud；

- 故障恢复 

  *任意时刻*因*任意故障*（包括但不限于：业务系统/RDBS服务器宕机；网络故障；断电等）造成的事务中断，ByteTCC均有相应机制予以恢复，保证全局事务的最终一致性。

- 幂等性

  ByteTCC<u>在框架层面提供对Confirm/Cancel业务逻辑的幂等性保障</u>，业务系统仅需关注自身业务本身，无需为幂等性问题而烦恼。

- 案例

  简化的电商下单步骤：1 扣减库存，2 创建订单，库存服务和订单服务分别在不同的服务器节点上；

  假设商品库存微100，购买数量2，检查和更新库存时，<u>冻结用户购买数量的库存，同时创建订单，订单状态微待确认</u>。

  1. )try阶段

  1.1 完成业务检查(强一致性)，1.2 预留必须业务资源(准备隔离性)  1.3 Try尝试执行业务

  ​	预更新库存为98(冻结2库存)；尝试创建订单(待确认)

  ​	协调器

  ​	2.) Confirm

  ​	当Try阶段服务全部正常执行，执行确认业务逻辑操作



### AT模式

- 无侵入自动补偿事务模式

### SAGA模式

- 为长事务提供有效解决方案

### XA模式



## Redison分布式方案